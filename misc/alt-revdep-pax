#!/usr/bin/env python

#
# Note: This alternative way of doing revdep-pax only
# works on Gentoo systems where NEEDED.ELF.2 all the
# information we need generated by scanelf during emerge.
#
# See /usr/lib/portage/bin/misc-functions.sh ~line 520
# echo "${arch:3};${obj};${soname};${rpath};${needed}" >> "${PORTAGE_BUILDDIR}"/build-info/NEEDED.ELF.2
#

import os
import sys
import re
import pax

def get_forward_needed():
	"""
	Return forward_needed dictionary which has structure

		{ full_path_to_ELF_object : [ soname1, soname2, ... ], ... }

	Here the sonames were obtained from the ELF object by readelf -d
	"""

	var_db_pkg = '/var/db/pkg'

	forward_needed = {}
	for cat in os.listdir(var_db_pkg):
		catdir = '%s/%s' % (var_db_pkg, cat)
		for pkg in os.listdir(catdir):
			pkgdir = '%s/%s' % (catdir, pkg)
			need = '%s/%s' % (pkgdir, 'NEEDED.ELF.2')
			try:
				g = open(need, 'r')
				needs = g.readlines()
				for line in needs:
					line = line.strip()
					link = re.split(';', line)
					elf = link[1]
					sonames = re.split(',', link[4])
					forward_needed[elf] = sonames
			except IOError:
				continue #File probably doesn't exist, which is okay

	return forward_needed


def get_library():
	"""
	Return library2soname dictionary which has structure

		{ full_path_to_library : soname, ... }

	and its inverse which has structure

		{ soname : full_path_to_library, ... }
	"""
	var_db_pkg = '/var/db/pkg'

	library2soname = {}
	soname2library = {}

	for cat in os.listdir(var_db_pkg):
		catdir = '%s/%s' % (var_db_pkg, cat)
		for pkg in os.listdir(catdir):
			pkgdir = '%s/%s' % (catdir, pkg)
			need = '%s/%s' % (pkgdir, 'NEEDED.ELF.2')
			try:
				g = open(need, 'r')
				needs = g.readlines()
				for line in needs:
					line = line.strip()
					link = re.split(';', line)
					elf = link[1]
					soname = link[2]
					if soname:				#no soname => executable
						library2soname[elf] = soname
						soname2library[soname] = elf
			except IOError:
				continue #File probably doesn't exist, which is okay

	return ( library2soname, soname2library )


def get_soname2soname_linkings( forward_needed, library2soname ):
	"""
	Return get_soname2soname_linkings dictionary which has structure:

		{ soname : [ soname1, soname2, ... ], .... }

	"""

	soname2soname_linkings = {}

	for elf in forward_needed:
		try:
			soname = library2soname[elf]
			soname2soname_linkings[soname] = forward_needed[elf]
		except KeyError:
			continue	#It doesn't have an soname and prabably isn't a library

	return soname2soname_linkings


def main():

	# Run as root to be able to real all files
	uid = os.getuid()
	if uid != 0:
		print('RUN AS ROOT: cannot read all flags')
		sys.exit(0)

	forward_needed = get_forward_needed()
	( library2soname, soname2library ) = get_library()

	soname2soname_linkings = get_soname2soname_linkings( forward_needed, library2soname )

	for soname in soname2soname_linkings:
		print("%s" % soname)
		for s in soname2soname_linkings[soname]:
			print("\t%s" % s )
		print('')

	""" Print out all ELF objects and their PaX flags
	for elf in forward_needed:
		try:
			flags = pax.getflags(elf)[0]
			if flags:
				print("%s %s" % (flags, elf))
			else:
				print("NONE: %s" % elf)
		except pax.error:
			print("CANT: %s" % elf)

	"""

	""" Print out all sonames and their library paths
	for soname in sorted(soname2library):
		elf = soname2library[soname]
		print("%s : %s" % ( soname, elf ))

	"""	

	""" Print out all ELF objects and the NEEDED sonames and full library paths
	for elf in forward_needed:
		sonames = forward_needed[elf]
		print("%s" % elf)
		for soname in sorted(forward_needed[elf]):
			try:
				print("\t%s\t=> %s" % (soname, soname2library[soname]))
			except KeyError:
				print("\t%s\t=> ****" % soname)
		print("\n\n")
	"""

if __name__ == '__main__':
	main()
