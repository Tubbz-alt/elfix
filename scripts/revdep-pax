#!/usr/bin/env python

import sys
import getopt
import os
import subprocess
import re
import pax

def get_ldd_linkings(binary):

	try:
		#TODO: when subprocess.DEVNULL makes it to python, change this: http://bugs.python.org/issue5870
		ldd_output = subprocess.check_output(['/usr/bin/ldd', binary], stderr=subprocess.PIPE)
	except:
		#TODO: we should record these binaries which are probably statically linked
		return []

	ldd_lines = ldd_output.split('\n')

	linkings = []
	mappings = {}
	for m in range(0,len(ldd_lines)):
		if not re.search('=>', ldd_lines[m]):
			continue
		ldd_lines[m] = ldd_lines[m].strip()
		mapp = re.split('=>', ldd_lines[m] )
		soname = mapp[0].strip()
		soname = os.path.basename(soname)	# This is for ./libSDL-1.2.so.0
		library = re.sub('\(.*$', '', mapp[1]).strip()
		if library == '':
			continue
		library = os.path.realpath(library)
		linkings.append(soname)
		mappings[soname] = library 

	return ( linkings, mappings )


def get_forward_linkings():
	#TODO: I'm still not sure we wan to use /var/db/pkg vs some path of binaries
	var_db_pkg = '/var/db/pkg'

	forward_linkings = {}
	so2library_mappings = {}
	for cat in os.listdir(var_db_pkg):
		catdir = '%s/%s' % (var_db_pkg, cat)
		for pkg in os.listdir(catdir):
			pkgdir = '%s/%s' % (catdir, pkg)
			need = '%s/%s' % (pkgdir, 'NEEDED')
			try:
				g = open(need, 'r')
				needs = g.readlines()
				for line in needs:
					line = line.strip()
					link = re.split('\s', line)
					binary = link[0]
					( linkings, mappings ) = get_ldd_linkings(binary)
					forward_linkings[binary] = linkings 
					so2library_mappings.update(mappings)
			except:
				continue

	return ( forward_linkings, so2library_mappings )


def invert_linkings( forward_linkings ):
	reverse_linkings = {}
	for binary in forward_linkings:
		for library in forward_linkings[binary]:
			reverse_linkings[library] = []

	for binary in forward_linkings:
		for library in forward_linkings[binary]:
			reverse_linkings[library].append(binary)

	return reverse_linkings 


def print_forward_linkings( forward_linkings, so2library_mappings, verbose ):
	missing_binaries = []
	missing_links = []
	for binary in forward_linkings:

		try:
			binary_flags = pax.getflags(binary)
			s = "%s ( %s )" % ( binary, binary_flags )
		except:
			missing_binaries.append(binary)
			continue

		count = 0
		for soname in forward_linkings[binary]:
			try:
				library = so2library_mappings[soname]
				library_flags = pax.getflags(library)
				s = "%s\n\t%s\t%s ( %s )" % ( s, soname, library, library_flags )
				if binary_flags != library_flags:
					count = count + 1
			except:
				missing_links.append(soname)

		if verbose:
			print s
			if count == 0:
				print 'No mismatches'
		else:
			if count != 0:
				print s

	print

	missing_binaries = set(missing_binaries)
	print
	print
	print '**** Missing binaries ****'
	for m in missing_binaries:
		print m

	missing_links = set(missing_links)
	print
	print
	print '**** Missing forward linkings ****'
	for m in missing_links:
		print m

	print
	print


def print_reverse_linkings( reverse_linkings, so2library_mappings, verbose ):
	missing_sonames = []
	missing_links = []

	for soname in reverse_linkings:

		try:
			library = so2library_mappings[soname]
			library_flags = pax.getflags(library)
			s = "%s\t%s ( %s )" % ( soname, library, library_flags )
		except:
			missing_sonames.append(soname)
			continue

		count = 0
		for binary in reverse_linkings[soname]:
			try:
				binary_flags = pax.getflags(binary)
				s = "%s\n\t%s ( %s )" % ( s, binary, binary_flags )
				if library_flags != binary_flags:
					count = count + 1
			except:
				missing_links.append(binary)

		if verbose:
			print s
			if count == 0:
				print 'No mismatches'
		else:
			if count != 0:
				print s

	print

	missing_sonames = set(missing_sonames)
	print
	print
	print '**** Missing sonames ****'
	for m in missing_sonames:
		print m

	missing_links = set(missing_links)
	print
	print
	print '**** Missing reverse linkings ****'
	for m in missing_links:
		print m
	print
	print


def run_usage():
	print 'Package Name : elfix'
	print 'Bug Reports  : http://bugs.gentoo.org/'
	print 'Program Name : revdep-pax'
	print 'Description  : Get or set pax flags on an ELF object'
	print
	print 'Usage        : revdep-pax [-fv] | [-rv] | -v [-b BINARY] | -v [-s SONAME] | -h'
	print
	print 'Options      : -f         print out all the forward mappings for all system binaries'
	print '             : -r         print out all the reverse mappints for all system sonames'
	print '             : -b BINARY  print all the forward mappings only for BINARY'
	print '             : -s SONAME  print all the reverse mappings only for SONAME'
	print '             : -v         verbose, otherwise just print mismatched pax flags'
	print '             : -h         print out this help'
	print


def run_forward(verbose):
	( forward_linkings, so2library_mappings ) = get_forward_linkings()
	print_forward_linkings( forward_linkings, so2library_mappings, verbose)


def run_reverse(verbose):
	( forward_linkings, so2library_mappings ) = get_forward_linkings()
	reverse_linkings = invert_linkings( forward_linkings )
	print_reverse_linkings( reverse_linkings, so2library_mappings, verbose )


def run_binary(binary, verbose):
	( linkings, mappings ) = get_ldd_linkings(binary)

	binary_flags = pax.getflags(binary)
	print binary, '(', binary_flags, ')'

	count = 0
	for soname in linkings:
		try:
			library = mappings[soname]
			library_flags = pax.getflags(library)
			if verbose:
				print '\t', soname, '\t', library, '(', library_flags, ')'
			else:
				if binary_flags != library_flags:
					print '\t', soname, '\t', library, '(', library_flags, ')'
					count = count + 1
		except:
			print "file for soname %s not found" % soname

	if count == 0:
		print
		print 'No mismatches'


def run_soname(soname, verbose):
	( forward_linkings, so2library_mappings ) = get_forward_linkings()
	reverse_linkings = invert_linkings( forward_linkings )
	linkings = reverse_linkings[soname]
	library = so2library_mappings[soname]

	library_flags = pax.getflags(library)
	print soname, '\t', library, '(', library_flags, ')'

	count = 0
	for binary in linkings:
		try:
			binary_flags = pax.getflags(binary)
			if verbose:
				print '\t', binary, '(', binary_flags, ')'
			else:
				if library_flags != binary_flags:
					print '\t', binary, '(', binary_flags, ')'
					count = count + 1
		except:
			print "cannot obtain pax flags for %s" % binary

	if count == 0:
		print
		print 'No mismatches'

def main():
	try:
		opts, args = getopt.getopt(sys.argv[1:], 'hfrb:s:v')
	except getopt.GetoptError, err:
		print str(err) # will print something like 'option -a not recognized'
		usage()
		sys.exit(1)

	if len(opts) == 0:
		usage()
		sys.exit(1)

	do_usage   = False
	do_forward = False
	do_reverse = False

	binary = None
	soname = None

	verbose = False

	for o, a in opts:
		if o == '-h':
			do_usage = True
		elif o == '-f':
			do_forward = True
		elif o == '-r':
			do_reverse = True
		elif o == '-b':
			binary = a
		elif o == '-s':
			soname = a
		elif o == '-v':
			verbose = True
		else:
			print 'Option included in getopt but not handled here!'
			print 'Please file a bug'
			sys.exit(1)

	#TODO: Add code to only allow one of -h, -f -r -b -s

	if do_usage:
		run_usage()

	if do_forward:
		run_forward(verbose)

	if do_reverse:
		run_reverse(verbose)

	if binary != None:
		run_binary(binary, verbose)

	if soname !=None:
		run_soname(soname, verbose)

if __name__ == '__main__':
    main()
